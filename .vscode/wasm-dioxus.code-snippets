{
	"AppBody": {
		"prefix": "AppBody",
		"body": [
			"let universe = use_ref(cx, Universe::new);",
			"// GameLoop",
			"",
			"cx.render(rsx! {",
			"    div { style: \"{CONTAINER_STYLE}\",",
			"        // PlayButton { is_playing: is_playing }",
			"        // Canvas { id: \"game-of-life-canvas\", universe: universe }",
			"    }",
			"})"
		]
	},
	"Canvas": {
		"prefix": "Canvas",
		"body": [
			"#[inline_props]",
			"#[allow(non_snake_case)]",
			"fn Canvas<'a>(cx: Scope<'a>, id: &'a str, universe: &'a UseRef<Universe>) -> Element {",
			"    let height = universe.read().height();",
			"    let width = universe.read().width();",
			"    let canvas_height = ((CELL_SIZE + 1) * height + 1) as i64;",
			"    let canvas_width = ((CELL_SIZE + 1) * width + 1) as i64;",
			"    let id = id.to_owned();",
			"    cx.render(rsx! { canvas { id: id, height: canvas_height, width: canvas_width } })",
			"}"
		]
	},
	"GameLoop": {
		"prefix": "GameLoop",
		"body": [
			"let is_playing = use_state(cx, || true);",
			"",
			"let universe_for_loop = universe.clone();",
			"use_future(cx, (is_playing,), move |(is_playing,)| async move {",
			"    while *is_playing.current() {",
			"        {",
			"            // caution this scope is necessary to ensure that all borrowed resources are dropped before entering the asynchronous workflow",
			"            let universe = universe_for_loop.clone();",
			"            let mut universe = universe.write_silent();",
			"            CanvasController::with(\"game-of-life-canvas\", &mut *universe).tick();",
			"        }",
			"        async_std::task::sleep(Duration::from_millis(1)).await;",
			"    }",
			"});"
		]
	},
	"implCanvasController": {
		"prefix": "implCanvasController",
		"body": [
			"impl<'a> CanvasController<'a> {",
			"    pub fn with(id: &str, universe: &'a mut Universe) -> CanvasController<'a> {",
			"        let window = web_sys::window().expect(\"global window does not exists\");",
			"        let document = window.document().expect(\"expecting a document on window\");",
			"        let canvas = document",
			"            .get_element_by_id(id)",
			"            .expect(\"expecting a canvas in the document\")",
			"            .dyn_into::<web_sys::HtmlCanvasElement>()",
			"            .unwrap();",
			"",
			"        let context = canvas",
			"            .get_context(\"2d\")",
			"            .unwrap()",
			"            .unwrap()",
			"            .dyn_into::<web_sys::CanvasRenderingContext2d>()",
			"            .unwrap();",
			"        Self { context, universe }",
			"    }",
			"",
			"    // Tick",
			"}"
		]
	},
	"Tick": {
		"prefix": "Tick",
		"body": [
			"pub fn tick(&mut self) {",
			"    self.universe.tick();",
			"",
			"    self.draw_cells();",
			"    self.draw_grid();",
			"}",
			"",
			"fn draw_cells(&self) {",
			"    self.context.begin_path();",
			"",
			"    self.draw_cells_with_style(|cell| cell == Cell::Alive, ALIVE_COLOR);",
			"    self.draw_cells_with_style(|cell| cell == Cell::Dead, DEAD_COLOR);",
			"",
			"    self.context.stroke();",
			"}",
			"",
			"fn draw_cells_with_style(&self, condition: impl Fn(Cell) -> bool, style: &str) {",
			"    self.context.set_fill_style(&style.into());",
			"    for row in 0..self.universe.height() {",
			"        for col in 0..self.universe.width() {",
			"            if !condition(self.universe[(row, col)]) {",
			"                continue;",
			"            }",
			"",
			"            self.context.fill_rect(",
			"                (col * (CELL_SIZE + 1) + 1) as f64,",
			"                (row * (CELL_SIZE + 1) + 1) as f64,",
			"                CELL_SIZE as f64,",
			"                CELL_SIZE as f64,",
			"            );",
			"        }",
			"    }",
			"}",
			"",
			"fn draw_grid(&self) {",
			"    self.context.begin_path();",
			"    self.context.set_stroke_style(&GRID_COLOR.into());",
			"",
			"    for i in 0..=self.universe.width() {",
			"        self.context.move_to((i * (CELL_SIZE + 1) + 1) as f64, 0f64);",
			"        self.context.line_to(",
			"            (i * (CELL_SIZE + 1) + 1) as f64,",
			"            ((CELL_SIZE + 1) * self.universe.height() + 1) as f64,",
			"        );",
			"    }",
			"",
			"    for i in 0..=self.universe.height() {",
			"        self.context.move_to(0f64, (i * (CELL_SIZE + 1) + 1) as f64);",
			"        self.context.line_to(",
			"            ((CELL_SIZE + 1) * self.universe.width() + 1) as f64,",
			"            (i * (CELL_SIZE + 1) + 1) as f64,",
			"        );",
			"    }",
			"",
			"    self.context.stroke();",
			"}"
		]
	},
	"PlayButton": {
		"prefix": "PlayButton",
		"body": [
			"#[inline_props]",
			"#[allow(non_snake_case)]",
			"fn PlayButton<'a>(cx: Scope<'a>, is_playing: &'a UseState<bool>) -> Element {",
			"    cx.render(rsx! {",
			"        button { onclick: move |_| {",
			"                is_playing.modify(|value| !value);",
			"            },",
			"            if *is_playing.get() { \"⏸\" } else { \"▶\" }",
			"        }",
			"    })",
			"}"
		]
	}
}
